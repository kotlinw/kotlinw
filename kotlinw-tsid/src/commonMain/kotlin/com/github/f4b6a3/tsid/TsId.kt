package com.github.f4b6a3.tsid

import kotlinx.datetime.Instant

/*
 * MIT License
 *
 * Copyright (c) 2020-2022 Fabio Lima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * A class that represents Time Sortable Identifiers (TSID).
 *
 *
 * TSID is a 64-bit value that has 2 components:
 *
 *  * **Time component (42 bits)**: a number of milliseconds since
 * 1970-01-01 (Unix epoch).
 *  * **Random component (22 bits)**: a sequence of random bits generated by
 * a secure random generator.
 *
 *
 *
 * The Random component has 2 sub-parts:
 *
 *  * **Node (0 to 20 bits)**: a number used to identify the machine or
 * node.
 *  * **Counter (2 to 22 bits)**: a randomly generated number that is
 * incremented whenever the time component is repeated.
 *
 *
 * The random component layout depend on the node bits. If the node bits are 10,
 * the counter bits are limited to 12. In this example, the maximum node value
 * is 2^10-1 = 1023 and the maximum counter value is 2^12-1 = 4093. So the
 * maximum TSIDs that can be generated per millisecond per node is 4096.
 *
 *
 * Instances of this class are **immutable**.
 *
 * @see [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID)
 */
class Tsid
/**
 * Creates a new TSID.
 *
 *
 * This constructor wraps the input value in an immutable object.
 *
 * @param number a number
 */(private val number: Long) : Comparable<Tsid> {
    /**
     * Convert the TSID into a number.
     *
     *
     * This method simply unwraps the internal value.
     *
     * @return an number.
     */
    fun toLong(): Long {
        return number
    }

    /**
     * Convert the TSID into a byte array.
     *
     * @return an byte array.
     */
    fun toBytes(): ByteArray {
        val bytes = ByteArray(TSID_BYTES)
        bytes[0x0] = (number ushr 56).toByte()
        bytes[0x1] = (number ushr 48).toByte()
        bytes[0x2] = (number ushr 40).toByte()
        bytes[0x3] = (number ushr 32).toByte()
        bytes[0x4] = (number ushr 24).toByte()
        bytes[0x5] = (number ushr 16).toByte()
        bytes[0x6] = (number ushr 8).toByte()
        bytes[0x7] = number.toByte()
        return bytes
    }

    /**
     * Converts the TSID into a canonical string in upper case.
     *
     *
     * The output string is 13 characters long and contains only characters from
     * Crockford's base 32 alphabet.
     *
     *
     * For lower case string, use the shorthand `Tsid#toLowerCase()`, instead
     * of `Tsid#toString()#toLowerCase()`.
     *
     * @return a TSID string
     * @see [Crockford's Base 32](https://www.crockford.com/base32.html)
     */
    override fun toString(): String {
        return toString(ALPHABET_UPPERCASE)
    }

    /**
     * Converts the TSID into a canonical string in lower case.
     *
     *
     * The output string is 13 characters long and contains only characters from
     * Crockford's base 32 alphabet.
     *
     *
     * It is faster shorthand for `Tsid#toString()#toLowerCase()`.
     *
     * @return a string
     * @see [Crockford's Base 32](https://www.crockford.com/base32.html)
     */
    fun toLowerCase(): String {
        return toString(ALPHABET_LOWERCASE)
    }

    val instant: Instant
        /**
         * Returns the instant of creation.
         *
         *
         * The instant of creation is extracted from the time component.
         *
         * @return [Instant]
         */
        get() = Instant.fromEpochMilliseconds(unixMilliseconds)

    /**
     * Returns the instant of creation.
     *
     *
     * The instant of creation is extracted from the time component.
     *
     * @param customEpoch the custom epoch instant
     * @return [Instant]
     */
    fun getInstant(customEpoch: Instant): Instant {
        return Instant.fromEpochMilliseconds(getUnixMilliseconds(customEpoch.toEpochMilliseconds()))
    }

    val unixMilliseconds: Long
        /**
         * Returns the time of creation in milliseconds since 1970-01-01.
         *
         *
         * The time of creation is extracted from the time component.
         *
         * @return the number of milliseconds since 1970-01-01
         */
        get() = time + TSID_EPOCH

    /**
     * Returns the time of creation in milliseconds since 1970-01-01.
     *
     *
     * The time of creation is extracted from the time component.
     *
     * @param customEpoch the custom epoch in milliseconds since 1970-01-01
     * @return the number of milliseconds since 1970-01-01
     */
    fun getUnixMilliseconds(customEpoch: Long): Long {
        return time + customEpoch
    }

    val time: Long
        /**
         * Returns the time component as a number.
         *
         *
         * The time component is a number between 0 and 2^42-1.
         *
         * @return a number of milliseconds.
         */
        get() = number ushr RANDOM_BITS
    val random: Long
        /**
         * Returns the random component as a number.
         *
         *
         * The time component is a number between 0 and 2^22-1.
         *
         * @return a number
         */
        get() = number and RANDOM_MASK.toLong()

    /**
     * Returns a hash code value for the TSID.
     */
    override fun hashCode(): Int {
        return (number xor (number ushr 32)).toInt()
    }

    /**
     * Checks if some other TSID is equal to this one.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Tsid) return false

        if (number != other.number) return false

        return true
    }

    /**
     * Compares two TSIDs as unsigned 64-bit integers.
     *
     *
     * The first of two TSIDs is greater than the second if the most significant
     * byte in which they differ is greater for the first TSID.
     *
     * @param other a TSID to be compared with
     * @return -1, 0 or 1 as `this` is less than, equal to, or greater than
     * `that`
     */
    override operator fun compareTo(other: Tsid): Int {

        // used to compare as UNSIGNED longs
        val min = Long.MIN_VALUE
        val a = number + min
        val b = other.number + min
        if (a > b) return 1 else if (a < b) return -1
        return 0
    }

    fun toString(alphabet: CharArray): String {
        val chars = CharArray(TSID_CHARS)
        chars[0x00] = alphabet[(number ushr 60 and 31L).toInt()]
        chars[0x01] = alphabet[(number ushr 55 and 31L).toInt()]
        chars[0x02] = alphabet[(number ushr 50 and 31L).toInt()]
        chars[0x03] = alphabet[(number ushr 45 and 31L).toInt()]
        chars[0x04] = alphabet[(number ushr 40 and 31L).toInt()]
        chars[0x05] = alphabet[(number ushr 35 and 31L).toInt()]
        chars[0x06] = alphabet[(number ushr 30 and 31L).toInt()]
        chars[0x07] = alphabet[(number ushr 25 and 31L).toInt()]
        chars[0x08] = alphabet[(number ushr 20 and 31L).toInt()]
        chars[0x09] = alphabet[(number ushr 15 and 31L).toInt()]
        chars[0x0a] = alphabet[(number ushr 10 and 31L).toInt()]
        chars[0x0b] = alphabet[(number ushr 5 and 31L).toInt()]
        chars[0x0c] = alphabet[(number and 31L).toInt()]
        return chars.concatToString()
    }

    companion object {
        private const val serialVersionUID = -5446820982139116297L

        /**
         * Number of bytes of a TSID.
         */
        const val TSID_BYTES = 8

        /**
         * Number of characters of a TSID.
         */
        const val TSID_CHARS = 13

        /**
         * Number of milliseconds of 2020-01-01T00:00:00.000Z.
         */
        val TSID_EPOCH: Long = Instant.parse("2020-01-01T00:00:00.000Z").toEpochMilliseconds()
        const val RANDOM_BITS = 22
        const val RANDOM_MASK = 0x003fffff
        private val ALPHABET_UPPERCASE = charArrayOf(
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',  //
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K',  //
            'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'
        )
        private val ALPHABET_LOWERCASE = charArrayOf(
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',  //
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k',  //
            'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'
        )
        private val ALPHABET_VALUES = LongArray(128)

        init {
            for (i in ALPHABET_VALUES.indices) {
                ALPHABET_VALUES[i] = -1
            }
            // Numbers
            ALPHABET_VALUES['0'.code] = 0x00
            ALPHABET_VALUES['1'.code] = 0x01
            ALPHABET_VALUES['2'.code] = 0x02
            ALPHABET_VALUES['3'.code] = 0x03
            ALPHABET_VALUES['4'.code] = 0x04
            ALPHABET_VALUES['5'.code] = 0x05
            ALPHABET_VALUES['6'.code] = 0x06
            ALPHABET_VALUES['7'.code] = 0x07
            ALPHABET_VALUES['8'.code] = 0x08
            ALPHABET_VALUES['9'.code] = 0x09
            // Lower case
            ALPHABET_VALUES['a'.code] = 0x0a
            ALPHABET_VALUES['b'.code] = 0x0b
            ALPHABET_VALUES['c'.code] = 0x0c
            ALPHABET_VALUES['d'.code] = 0x0d
            ALPHABET_VALUES['e'.code] = 0x0e
            ALPHABET_VALUES['f'.code] = 0x0f
            ALPHABET_VALUES['g'.code] = 0x10
            ALPHABET_VALUES['h'.code] = 0x11
            ALPHABET_VALUES['j'.code] = 0x12
            ALPHABET_VALUES['k'.code] = 0x13
            ALPHABET_VALUES['m'.code] = 0x14
            ALPHABET_VALUES['n'.code] = 0x15
            ALPHABET_VALUES['p'.code] = 0x16
            ALPHABET_VALUES['q'.code] = 0x17
            ALPHABET_VALUES['r'.code] = 0x18
            ALPHABET_VALUES['s'.code] = 0x19
            ALPHABET_VALUES['t'.code] = 0x1a
            ALPHABET_VALUES['v'.code] = 0x1b
            ALPHABET_VALUES['w'.code] = 0x1c
            ALPHABET_VALUES['x'.code] = 0x1d
            ALPHABET_VALUES['y'.code] = 0x1e
            ALPHABET_VALUES['z'.code] = 0x1f
            // Lower case OIL
            ALPHABET_VALUES['o'.code] = 0x00
            ALPHABET_VALUES['i'.code] = 0x01
            ALPHABET_VALUES['l'.code] = 0x01
            // Upper case
            ALPHABET_VALUES['A'.code] = 0x0a
            ALPHABET_VALUES['B'.code] = 0x0b
            ALPHABET_VALUES['C'.code] = 0x0c
            ALPHABET_VALUES['D'.code] = 0x0d
            ALPHABET_VALUES['E'.code] = 0x0e
            ALPHABET_VALUES['F'.code] = 0x0f
            ALPHABET_VALUES['G'.code] = 0x10
            ALPHABET_VALUES['H'.code] = 0x11
            ALPHABET_VALUES['J'.code] = 0x12
            ALPHABET_VALUES['K'.code] = 0x13
            ALPHABET_VALUES['M'.code] = 0x14
            ALPHABET_VALUES['N'.code] = 0x15
            ALPHABET_VALUES['P'.code] = 0x16
            ALPHABET_VALUES['Q'.code] = 0x17
            ALPHABET_VALUES['R'.code] = 0x18
            ALPHABET_VALUES['S'.code] = 0x19
            ALPHABET_VALUES['T'.code] = 0x1a
            ALPHABET_VALUES['V'.code] = 0x1b
            ALPHABET_VALUES['W'.code] = 0x1c
            ALPHABET_VALUES['X'.code] = 0x1d
            ALPHABET_VALUES['Y'.code] = 0x1e
            ALPHABET_VALUES['Z'.code] = 0x1f
            // Upper case OIL
            ALPHABET_VALUES['O'.code] = 0x00
            ALPHABET_VALUES['I'.code] = 0x01
            ALPHABET_VALUES['L'.code] = 0x01
        }

        /**
         * Converts a number into a TSID.
         *
         *
         * This method wraps the input value in an immutable object.
         *
         * @param number a number
         * @return a TSID
         */
        fun from(number: Long): Tsid {
            return Tsid(number)
        }

        /**
         * Converts a byte array into a TSID.
         *
         * @param bytes a byte array
         * @return a TSID
         * @throws IllegalArgumentException if bytes are null or its length is not 8
         */
        fun from(bytes: ByteArray?): Tsid {
            require(!(bytes == null || bytes.size != TSID_BYTES)) {
                "Invalid TSID bytes" // null or wrong length!
            }
            var number: Long = 0
            number = number or (bytes[0x0].toLong() and 0xffL shl 56)
            number = number or (bytes[0x1].toLong() and 0xffL shl 48)
            number = number or (bytes[0x2].toLong() and 0xffL shl 40)
            number = number or (bytes[0x3].toLong() and 0xffL shl 32)
            number = number or (bytes[0x4].toLong() and 0xffL shl 24)
            number = number or (bytes[0x5].toLong() and 0xffL shl 16)
            number = number or (bytes[0x6].toLong() and 0xffL shl 8)
            number = number or (bytes[0x7].toLong() and 0xffL)
            return Tsid(number)
        }

        /**
         * Converts a canonical string into a TSID.
         *
         *
         * The input string must be 13 characters long and must contain only characters
         * from Crockford's base 32 alphabet.
         *
         *
         * The first character of the input string must be between 0 and F.
         *
         * @param string a canonical string
         * @return a TSID
         * @throws IllegalArgumentException if the input string is invalid
         * @see [Crockford's Base 32](https://www.crockford.com/base32.html)
         */
        fun from(string: String?): Tsid {
            val chars = toCharArray(string)
            var number: Long = 0
            number = number or (ALPHABET_VALUES[chars!![0x00].code] shl 60)
            number = number or (ALPHABET_VALUES[chars[0x01].code] shl 55)
            number = number or (ALPHABET_VALUES[chars[0x02].code] shl 50)
            number = number or (ALPHABET_VALUES[chars[0x03].code] shl 45)
            number = number or (ALPHABET_VALUES[chars[0x04].code] shl 40)
            number = number or (ALPHABET_VALUES[chars[0x05].code] shl 35)
            number = number or (ALPHABET_VALUES[chars[0x06].code] shl 30)
            number = number or (ALPHABET_VALUES[chars[0x07].code] shl 25)
            number = number or (ALPHABET_VALUES[chars[0x08].code] shl 20)
            number = number or (ALPHABET_VALUES[chars[0x09].code] shl 15)
            number = number or (ALPHABET_VALUES[chars[0x0a].code] shl 10)
            number = number or (ALPHABET_VALUES[chars[0x0b].code] shl 5)
            number = number or ALPHABET_VALUES[chars[0x0c].code]
            return Tsid(number)
        }

        /**
         * Checks if the input string is valid.
         *
         *
         * The input string must be 13 characters long and must contain only characters
         * from Crockford's base 32 alphabet.
         *
         *
         * The first character of the input string must be between 0 and F.
         *
         * @param string a string
         * @return true if valid
         */
        fun isValid(string: String?): Boolean {
            return string != null && isValidCharArray(string.toCharArray())
        }

        fun toCharArray(string: String?): CharArray? {
            val chars = string?.toCharArray()
            if (!isValidCharArray(chars)) {
                throw IllegalArgumentException("Invalid TSID: \"$string\"")
            }
            return chars
        }

        /**
         * Checks if the string is a valid TSID.
         *
         * A valid TSID string is a sequence of 13 characters from Crockford's base 32
         * alphabet.
         *
         * The first character of the input string must be between 0 and F.
         *
         * @param chars a char array
         * @return boolean true if valid
         */
        fun isValidCharArray(chars: CharArray?): Boolean {
            if (chars == null || chars.size != TSID_CHARS) {
                return false // null or wrong size!
            }

            // The extra bit added by base-32 encoding must be zero
            // As a consequence, the 1st char of the input string must be between 0 and F.
            if (ALPHABET_VALUES[chars[0].code] and 16L != 0L) {
                return false // overflow!
            }
            for (i in chars.indices) {
                if (ALPHABET_VALUES[chars[i].code] == -1L) {
                    return false // invalid character!
                }
            }
            return true // It seems to be OK.
        }
    }
}
